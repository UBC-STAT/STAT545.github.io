{
  "hash": "e92572d2c549553fef3a0fe30b356793",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Date and Times on NYC Flights\"\nsubtitle: \"Lecture 6b Case Study (WITH SOLUTIONS)\"\ndate-modified: last-modified\n---\n\n\n\n\nDownload the case study [here](https://github.com/UBC-STAT/STAT545.github.io/blob/main/content/casestudies/casestudy_dates/casestudy_dates_SOLUTIONS.Rmd).\n\n## NYC Flights Data\n\nThe NYC Flights data set contains (among many other things) on-time performance data for all flights departing a New York City airport in 2013. Let’s load it from the package `nycflights13`. Let’s also load the tidyverse; the key package we will be using from it today is lubridate.\n\nThere’s lots to explore in this data set, and lots of variables! We’ll work with a super pared down version.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(nycflights13)\n\nflights_demo <- flights %>% \n  select(year, month, day, hour, minute, flight, carrier)\n\nhead(flights_demo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n   year month   day  hour minute flight carrier\n  <int> <int> <int> <dbl>  <dbl>  <int> <chr>  \n1  2013     1     1     5     15   1545 UA     \n2  2013     1     1     5     29   1714 UA     \n3  2013     1     1     5     40   1141 AA     \n4  2013     1     1     5     45    725 B6     \n5  2013     1     1     6      0    461 DL     \n6  2013     1     1     5     58   1696 UA     \n```\n\n\n:::\n:::\n\n\n\n\nThis currently contains the scheduled departure time of every flight, as well its carrier and flight code.\n\n## Exercises\n\n### **Date-Time Creation and Extraction**\n\nI want to add a fake flight to this data set: AC 123, scheduled to depart at 9:00am on Oct 1 2013.\n\nWe can use a family of functions named as permutations of “y”, “m”, and “d” to convert character input into special Date objects.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdy(\"Oct 1 2013\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2013-10-01\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmdy(\"October 1st 2013\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2013-10-01\"\n```\n\n\n:::\n:::\n\n\n\n\nWe just need to get the order right in what’s passed in - lubridate does the rest!\n\nWe can use a similar family of functions to convert character input into special Date-Time objects. Let’s be careful to get the timezone right too, in case it turns out to be important later.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(new_sched_dep_time <- mdy_hm(\"Oct 1 2013 9:00\", tz = \"America/New_York\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2013-10-01 09:00:00 EDT\"\n```\n\n\n:::\n:::\n\n\n\n\nNow let’s make a 1-row tibble with the components we need: year, month, day, hour, minute, carrier, and flight code. The key will be the `year()`, `month()`, etc. functions from the lubridate package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(new_flight <- tribble(~year, ~month, ~day, ~hour, ~minute, ~flight, ~carrier, \n                      year(new_sched_dep_time), month(new_sched_dep_time), \n                      day(new_sched_dep_time), hour(new_sched_dep_time), \n                      minute(new_sched_dep_time), 123, \"AC\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n   year month   day  hour minute flight carrier\n  <dbl> <dbl> <int> <int>  <int>  <dbl> <chr>  \n1  2013    10     1     9      0    123 AC     \n```\n\n\n:::\n:::\n\n\n\n\nLike magic!!! We can then add it to the `flights_demo` dataset using `bind_rows()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_demo <- bind_rows(flights_demo, new_flight)\n```\n:::\n\n\n\n\n### **Date-Time Math**\n\nThe full `flights` dataset has info about the departure delays of these flights. Let’s make another simplified version for demo purposes with that info.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_demo2 <- flights %>% \n  select(year, month, day, dep_time, sched_dep_time, dep_delay)\n\nhead(flights_demo2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n   year month   day dep_time sched_dep_time dep_delay\n  <int> <int> <int>    <int>          <int>     <dbl>\n1  2013     1     1      517            515         2\n2  2013     1     1      533            529         4\n3  2013     1     1      542            540         2\n4  2013     1     1      544            545        -1\n5  2013     1     1      554            600        -6\n6  2013     1     1      554            558        -4\n```\n\n\n:::\n:::\n\n\n\n\nThe `dep_delay` variable contains the number of minutes the flight departs either early or late, with a positive number if the flight departs late, and a negative number if the flight departs early. How was this variable made?\n\nLet’s see one way how. Let’s make two Date-Time objects corresponding to the departure and scheduled departure of our fake flight. If we *subtract* them, then we get a `difftime` object.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_sched_dep_time <- ymd_hm(\"2013 October 1 9:00\", tz = \"America/New_York\")\nnew_dep_time <- ymd_hm(\"2013 Oct 1 9:15\", tz = \"America/New_York\")\n\nnew_dep_time - new_sched_dep_time \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 15 mins\n```\n\n\n:::\n:::\n\n\n\n\nBeautiful! In this case, this calculation was easy to do by hand, but it would’ve been more annoying if we were calculating the time elapsed between (say) December 11th 2010 3:17am and March 24th 2011 11:51pm.\n\n`difftime` objects produce human readable output, but can be a little annoying when you want output in consistent units. `duration` objects to the rescue - they always use seconds! Let’s do the math again but this time coerce the result to a `duration` object.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(duration_delay <- as.duration(new_dep_time - new_sched_dep_time))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"900s (~15 minutes)\"\n```\n\n\n:::\n:::\n\n\n\n\nFinally we can convert this to minutes by creating a `duration` object that spans a minute using the convenience function `dminutes()`, and doing date-time division.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nduration_delay/dminutes(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}